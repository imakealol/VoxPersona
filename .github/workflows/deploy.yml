name: Parallel VoxPersona Deployment

on:
  workflow_run:
    workflows: ["Python application"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      force_restart_type:
        description: 'Force specific restart type'
        required: false
        default: 'auto'
        type: choice
        options:
        - auto
        - full
        - app-only
        - no-restart
      target_environment:
        description: 'Target deployment environment'
        required: false
        default: 'both'
        type: choice
        options:
        - both
        - production
        - dev

env:
  SSH_OPTIONS: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"

jobs:
  # ============================================================
  # JOB 1: Analyze Changes (Ğ¾Ğ´Ğ¸Ğ½ Ñ€Ğ°Ğ· Ğ´Ğ»Ñ Ğ²ÑĞµÑ… ÑĞµÑ€Ğ²ĞµÑ€Ğ¾Ğ²)
  # ============================================================
  analyze-changes:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event.workflow_run.conclusion == 'success'

    outputs:
      deployment_type: ${{ steps.deployment_analysis.outputs.deployment_type }}
      changed_files_count: ${{ steps.deployment_analysis.outputs.changed_files_count }}
      new_commit: ${{ github.sha }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Validate and sanitize user inputs
      id: validate_inputs
      env:
        USER_RESTART_TYPE: ${{ github.event.inputs.force_restart_type || 'auto' }}
      run: |
        echo "ğŸ”’ Validating user inputs for security..."
        case "$USER_RESTART_TYPE" in
          "auto"|"full"|"app-only"|"no-restart")
            echo "âœ… Valid restart type: $USER_RESTART_TYPE"
            echo "validated_restart_type=$USER_RESTART_TYPE" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "âŒ Invalid restart type: $USER_RESTART_TYPE"
            exit 1
            ;;
        esac

    - name: Analyze changes and determine deployment type
      id: deployment_analysis
      env:
        VALIDATED_RESTART_TYPE: ${{ steps.validate_inputs.outputs.validated_restart_type }}
      run: |
        echo "ğŸ” Analyzing changes to determine deployment type..."

        # Get changed files in last commit
        CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "initial")
        echo "Changed files:"
        echo "$CHANGED_FILES"

        # Determine deployment type
        if [ "$VALIDATED_RESTART_TYPE" != "" ] && [ "$VALIDATED_RESTART_TYPE" != "auto" ]; then
          case "$VALIDATED_RESTART_TYPE" in
            "full") DEPLOY_TYPE="FULL_RESTART" ;;
            "app-only") DEPLOY_TYPE="APP_ONLY" ;;
            "no-restart") DEPLOY_TYPE="NO_RESTART" ;;
          esac
          echo "ğŸ¯ Manual deployment type: $DEPLOY_TYPE"
        else
          # Automatic detection
          if echo "$CHANGED_FILES" | grep -E "(docker-compose\.yml|Dockerfile|requirements\.txt|\.sql$|sql_scripts/)" > /dev/null; then
            DEPLOY_TYPE="FULL_RESTART"
          elif echo "$CHANGED_FILES" | grep -E "(\.py$|src/|prompts/|prompts-by-scenario/)" > /dev/null; then
            DEPLOY_TYPE="APP_ONLY"
          elif echo "$CHANGED_FILES" | grep -E "(\.md$|\.txt$|\.rst$|README|CHANGELOG|\.gitignore$)" > /dev/null; then
            DEPLOY_TYPE="NO_RESTART"
          else
            DEPLOY_TYPE="APP_ONLY"
          fi
        fi

        echo "deployment_type=$DEPLOY_TYPE" >> $GITHUB_OUTPUT
        echo "changed_files_count=$(echo '$CHANGED_FILES' | wc -l)" >> $GITHUB_OUTPUT
        echo "ğŸ“‹ Final deployment decision: $DEPLOY_TYPE"

  # ============================================================
  # JOB 2: Deploy to MIRAGE Production
  # ============================================================
  deploy-production:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: analyze-changes
    if: |
      github.event.inputs.target_environment == 'both' ||
      github.event.inputs.target_environment == 'production' ||
      github.event.inputs.target_environment == null

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH Key
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Add MIRAGE to known hosts
      run: |
        ssh-keyscan -p ${{ secrets.MIRAGE_SERVER_PORT }} -H ${{ secrets.MIRAGE_SERVER_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

    - name: Test SSH Connection to MIRAGE
      run: |
        echo "ğŸ”— Testing SSH connection to MIRAGE Production..."
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.MIRAGE_SERVER_PORT }} ${{ secrets.MIRAGE_SERVER_USER }}@${{ secrets.MIRAGE_SERVER_IP }} "echo 'âœ… SSH connection to MIRAGE successful'"

    - name: Sync repository to MIRAGE
      run: |
        echo "ğŸ”„ Syncing repository to MIRAGE Production..."
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.MIRAGE_SERVER_PORT }} ${{ secrets.MIRAGE_SERVER_USER }}@${{ secrets.MIRAGE_SERVER_IP }} "
          if [ ! -d '${{ secrets.MIRAGE_DEPLOY_PATH }}/.git' ]; then
            echo 'ğŸ†• Cloning repository for first time...'
            mkdir -p \$(dirname ${{ secrets.MIRAGE_DEPLOY_PATH }})
            rm -rf ${{ secrets.MIRAGE_DEPLOY_PATH }}
            git clone https://github.com/${{ github.repository }}.git ${{ secrets.MIRAGE_DEPLOY_PATH }}
          else
            echo 'ğŸ“¥ Updating existing repository...'
            cd ${{ secrets.MIRAGE_DEPLOY_PATH }}
            git fetch origin
            git reset --hard origin/main
          fi
        "

    - name: Check .env file on MIRAGE
      run: |
        echo "ğŸ“ Checking .env file on MIRAGE..."
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.MIRAGE_SERVER_PORT }} ${{ secrets.MIRAGE_SERVER_USER }}@${{ secrets.MIRAGE_SERVER_IP }} "
          cd ${{ secrets.MIRAGE_DEPLOY_PATH }}
          if [ -f .env ]; then
            echo 'âœ… .env file exists'
          else
            echo 'âŒ ERROR: .env file not found! Create it manually on the server.'
            exit 1
          fi
        "

    - name: Execute deployment on MIRAGE
      env:
        DEPLOY_TYPE: ${{ needs.analyze-changes.outputs.deployment_type }}
      run: |
        echo "ğŸš€ Executing $DEPLOY_TYPE deployment on MIRAGE Production..."
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.MIRAGE_SERVER_PORT }} ${{ secrets.MIRAGE_SERVER_USER }}@${{ secrets.MIRAGE_SERVER_IP }} "
          cd ${{ secrets.MIRAGE_DEPLOY_PATH }}

          case '$DEPLOY_TYPE' in
            'FULL_RESTART')
              echo 'ğŸ”„ FULL_RESTART on MIRAGE...'
              docker compose down || true
              DOCKER_BUILDKIT=1 docker compose build --pull
              docker compose up -d
              ;;
            'APP_ONLY')
              echo 'ğŸš€ APP_ONLY on MIRAGE...'
              docker compose stop voxpersona || true
              DOCKER_BUILDKIT=1 docker compose build voxpersona
              docker compose up -d voxpersona
              ;;
            'NO_RESTART')
              echo 'ğŸ“ NO_RESTART on MIRAGE - files synced only'
              ;;
          esac
        "

    - name: Health check MIRAGE
      if: needs.analyze-changes.outputs.deployment_type != 'NO_RESTART'
      run: |
        echo "ğŸ¥ Running health checks on MIRAGE..."
        sleep 20
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.MIRAGE_SERVER_PORT }} ${{ secrets.MIRAGE_SERVER_USER }}@${{ secrets.MIRAGE_SERVER_IP }} "
          cd ${{ secrets.MIRAGE_DEPLOY_PATH }}
          docker compose ps

          CONTAINER_STATUS=\$(docker ps --filter 'name=voxpersona_app' --format '{{.Status}}')
          if [[ \$CONTAINER_STATUS == *'Up'* ]] || [[ \$CONTAINER_STATUS == *'healthy'* ]]; then
            echo 'âœ… MIRAGE VoxPersona container is running'
          else
            echo 'âŒ MIRAGE VoxPersona container failed'
            docker compose logs --tail=50 voxpersona
            exit 1
          fi
        "

    - name: Log deployment on MIRAGE
      run: |
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.MIRAGE_SERVER_PORT }} ${{ secrets.MIRAGE_SERVER_USER }}@${{ secrets.MIRAGE_SERVER_IP }} "
          echo \"\$(date -Iseconds) [DEPLOY] ${{ needs.analyze-changes.outputs.deployment_type }}: ${{ github.sha }}\" >> ${{ secrets.MIRAGE_DEPLOY_PATH }}/deployment.log
        "

  # ============================================================
  # JOB 3: Deploy to OLD Server Dev/Staging (parallel)
  # ============================================================
  deploy-dev:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: analyze-changes
    if: |
      github.event.inputs.target_environment == 'both' ||
      github.event.inputs.target_environment == 'dev' ||
      github.event.inputs.target_environment == null

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH Key
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Add Dev Server to known hosts
      run: |
        ssh-keyscan -p ${{ secrets.DEV_SERVER_PORT }} -H ${{ secrets.DEV_SERVER_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

    - name: Test SSH Connection to Dev Server
      run: |
        echo "ğŸ”— Testing SSH connection to Dev Server..."
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.DEV_SERVER_PORT }} ${{ secrets.DEV_SERVER_USER }}@${{ secrets.DEV_SERVER_IP }} "echo 'âœ… SSH connection to Dev Server successful'"

    - name: Sync repository to Dev Server
      run: |
        echo "ğŸ”„ Syncing repository to Dev Server..."
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.DEV_SERVER_PORT }} ${{ secrets.DEV_SERVER_USER }}@${{ secrets.DEV_SERVER_IP }} "
          if [ ! -d '${{ secrets.DEV_DEPLOY_PATH }}/.git' ]; then
            echo 'ğŸ†• Cloning repository for first time...'
            mkdir -p \$(dirname ${{ secrets.DEV_DEPLOY_PATH }})
            rm -rf ${{ secrets.DEV_DEPLOY_PATH }}
            git clone https://github.com/${{ github.repository }}.git ${{ secrets.DEV_DEPLOY_PATH }}
          else
            echo 'ğŸ“¥ Updating existing repository...'
            cd ${{ secrets.DEV_DEPLOY_PATH }}
            git fetch origin
            git reset --hard origin/main
          fi
        "

    - name: Check .env file on Dev Server
      run: |
        echo "ğŸ“ Checking .env file on Dev Server..."
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.DEV_SERVER_PORT }} ${{ secrets.DEV_SERVER_USER }}@${{ secrets.DEV_SERVER_IP }} "
          cd ${{ secrets.DEV_DEPLOY_PATH }}
          if [ -f .env ]; then
            echo 'âœ… .env file exists'
          else
            echo 'âŒ ERROR: .env file not found! Create it manually on the server.'
            exit 1
          fi
        "

    - name: Execute deployment on Dev Server
      env:
        DEPLOY_TYPE: ${{ needs.analyze-changes.outputs.deployment_type }}
      run: |
        echo "ğŸš€ Executing $DEPLOY_TYPE deployment on Dev Server..."
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.DEV_SERVER_PORT }} ${{ secrets.DEV_SERVER_USER }}@${{ secrets.DEV_SERVER_IP }} "
          cd ${{ secrets.DEV_DEPLOY_PATH }}

          case '$DEPLOY_TYPE' in
            'FULL_RESTART')
              echo 'ğŸ”„ FULL_RESTART on Dev Server...'
              docker compose down || true
              DOCKER_BUILDKIT=1 docker compose build --pull
              docker compose up -d
              ;;
            'APP_ONLY')
              echo 'ğŸš€ APP_ONLY on Dev Server...'
              docker compose stop voxpersona || true
              DOCKER_BUILDKIT=1 docker compose build voxpersona
              docker compose up -d voxpersona
              ;;
            'NO_RESTART')
              echo 'ğŸ“ NO_RESTART on Dev Server - files synced only'
              ;;
          esac
        "

    - name: Health check Dev Server
      if: needs.analyze-changes.outputs.deployment_type != 'NO_RESTART'
      run: |
        echo "ğŸ¥ Running health checks on Dev Server..."
        sleep 20
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.DEV_SERVER_PORT }} ${{ secrets.DEV_SERVER_USER }}@${{ secrets.DEV_SERVER_IP }} "
          cd ${{ secrets.DEV_DEPLOY_PATH }}
          docker compose ps

          CONTAINER_STATUS=\$(docker ps --filter 'name=voxpersona_app' --format '{{.Status}}')
          if [[ \$CONTAINER_STATUS == *'Up'* ]] || [[ \$CONTAINER_STATUS == *'healthy'* ]]; then
            echo 'âœ… Dev VoxPersona container is running'
          else
            echo 'âŒ Dev VoxPersona container failed'
            docker compose logs --tail=50 voxpersona
            exit 1
          fi
        "

    - name: Log deployment on Dev Server
      run: |
        ssh ${{ env.SSH_OPTIONS }} -p ${{ secrets.DEV_SERVER_PORT }} ${{ secrets.DEV_SERVER_USER }}@${{ secrets.DEV_SERVER_IP }} "
          echo \"\$(date -Iseconds) [DEPLOY] ${{ needs.analyze-changes.outputs.deployment_type }}: ${{ github.sha }}\" >> ${{ secrets.DEV_DEPLOY_PATH }}/deployment.log
        "

  # ============================================================
  # JOB 4: Deployment Summary
  # ============================================================
  deployment-summary:
    runs-on: ubuntu-latest
    needs: [analyze-changes, deploy-production, deploy-dev]
    if: always()

    steps:
    - name: Generate deployment summary
      env:
        DEPLOY_TYPE: ${{ needs.analyze-changes.outputs.deployment_type }}
        FILES_CHANGED: ${{ needs.analyze-changes.outputs.changed_files_count }}
        PROD_STATUS: ${{ needs.deploy-production.result }}
        DEV_STATUS: ${{ needs.deploy-dev.result }}
      run: |
        echo "ğŸ“Š =============================================="
        echo "ğŸ“Š DEPLOYMENT SUMMARY"
        echo "ğŸ“Š =============================================="
        echo "ğŸ“‹ Deployment Type: $DEPLOY_TYPE"
        echo "ğŸ“ Files Changed: $FILES_CHANGED"
        echo "ğŸ­ Production (MIRAGE): $PROD_STATUS"
        echo "ğŸ§ª Dev (OLD Server): $DEV_STATUS"
        echo "ğŸ“Š =============================================="

        if [ "$PROD_STATUS" == "success" ] && [ "$DEV_STATUS" == "success" ]; then
          echo "âœ… All deployments completed successfully!"
        elif [ "$PROD_STATUS" == "success" ] && [ "$DEV_STATUS" == "skipped" ]; then
          echo "âœ… Production deployment completed successfully!"
        elif [ "$PROD_STATUS" == "skipped" ] && [ "$DEV_STATUS" == "success" ]; then
          echo "âœ… Dev deployment completed successfully!"
        elif [ "$PROD_STATUS" == "skipped" ] && [ "$DEV_STATUS" == "skipped" ]; then
          echo "â­ï¸ Both deployments skipped (target_environment filter)"
        else
          echo "âŒ Some deployments failed. Check logs above."
          if [ "$PROD_STATUS" == "failure" ]; then
            echo "  ğŸ­ Production failed!"
          fi
          if [ "$DEV_STATUS" == "failure" ]; then
            echo "  ğŸ§ª Dev failed!"
          fi
          exit 1
        fi
